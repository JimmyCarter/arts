# 消息传递可提高并行系统的可伸缩性

[Message Passing Leads to Better Scalability in Parallel Systems](~https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_57/~)

程序员在他们还是个计算机小白时就被灌输并发的概念——尤其是并行(并发的一种子集)——相当有难度的东西，只能寄希望于极少数优秀的人把它们搞明白，但很可能最后他们也是一脸懵逼。有关多线程、信号量、监视器，以及如何并发访问变量的线程安全等问题，常常是人们关注的重点。

说真的，这里面存在很多难题，而且想要解决它们都非常不容易。但这些问题的根源又是什么？共享内存。人们不断遇到的并发问题几乎都和共享内存的使用相关：竞争机制、死锁、活锁，等等。解决这些的答案也很明显：要么放弃并发，要么避开共享内存。

放弃并发？呵呵，别闹了。几乎每个季度计算机都会有越来越多的核，因此真正利用并行优势也变得越来越重要。我们没必要完全依赖处理器的时钟速度的增长，来改善应用程序的性能。只需要充分发挥并行，应用程序性能就会改善。显然，不提高性能可能是个选项，但用户不答应！

所以，我们只能避开共享内存咯？嗯哼。

作为线程+共享内存的替代方案，可以使用进程和消息传递来作为我们的编程模型。这里所说的“进程”不一定是操作系统下的进程概念，只要是一段受保护且独立执行的代码即可。正如Relang(和它之前的occam)之类的编程语言所展示的那样：进程，是在并发和并行系统编程中非常成功的机制。此类系统没有共享内存的同步压力，而多线程系统却有。此外，还有一个正式的模型可应用于此类系统的引擎部分——通信顺序进程(CSP)。

作为一种计算方法，我们会进一步介绍数据流系统。在数据流系统中，没有明确编程的控制流。而是通过一张操作图表，根据数据路径进行连接，将数据馈送到系统中。由系统数据的就绪情况进行评估控制，就杜绝了同步问题。

说那么多，像C、C++、Java、Python和Groovy这样系统级的编程语言，都作为开发共享内存和多线程系统的语言提供给开发者。那该怎么办？答案是使用(如果不存在，就创建)——提供了进程模型和消息传递的库和框架，从而避免内存的使用。

总之，不采用共享内存进行编程，而要用消息传递来取代，在现如今主流的计算机硬件的系统开发中，这或许是充分利用并行性的最好方式。也许这听起来很奇怪：尽管进程之前是用线程作为并发单元，但未来似乎将使用线程来实现进程。
