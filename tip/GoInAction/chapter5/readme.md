# 《GO语言实战》学习笔记五：类型系统

类型——比“类”多了一个字而已，如果懂面向对象的话，类型的很多内容其实和面向对象**语言**如出一辙，但不同于面向对象**思想**。换而言之，Java/C#等常见的类的属性、方法、接口、继承等等形式，在GO的类型系统里都能找到身影，但其实现过程和思路却截然不同。

## 类型的定义与属性

## 类型的方法

根据面向对象的套路，定义了类型的属性，自然少不了要定义方法，但GO语言不允许直接把一个类型的方法定义在其内部，而是可以将其定义在任何其他地方。如果习惯了Java这种方式，可能会觉得十分别扭，但这正是GO类型灵活的地方。如果你觉得某个“业务对象”需要某个特殊的方法来处理，那就直接加上好了，不影响它的继承、耦合等问题。

给类型添加一个方法的基本语法为：
```go
// obj表示接收者，可以理解为面向对象中的一个对象
func (u User) method() {
		u.name = "philon"
		u.email = "xxx@xxx.com"
}
```

类型的方法定义根据“接收者”的形式，主要分为两种：
```go
// 值调用定义
func (u User) getEmail() {}
// 指针调用定义
func (u *User) setEmail(email string) {}
```

如果理解函数调用的内存管理，那这两种形式非常容易理解。调用函数的时候，传入的参数将拷贝一个副本并压栈，函数通过访问栈区来获取参数值。换句话说：**所有传入函数的参数其实都只是副本**，在函数内部修改副本的值，不会影响原始参数值。

所以

- `值接收者`的方法在其内部修改对象的值，不改变外部调用者
- `指针接收者`的方法在其内部修改对象的值，改变外部调用者

### 值调用

### 指针调用

## 接口与继承

## 小结一下