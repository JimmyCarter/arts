《GO语言实战》学习笔记三

本章开始，进入GO语言的基本数据结构的学习。我认为无论如何还是要仔细读一遍第4-6章，和其他“胎教”类的教科书不一样，这几章内容并不是教你：*int表示一种整数、汽车摩托车都是车类，轮子是一种属性，跑是一种方法、数组就是一种连续的空间*。相反，以本章内容为例，单刀直入告诉你数组、切片、映射的内存结构，实现原理，以及一些高级用法，不论新手老手，读一读总能有所收获。

## 数组
GO语言的数组类型和绝大多数其他编程语言的思想是类似的，没有太多新东西，把基本用法掌握即可。

### 基本定义

```go
// 1. 声明一个包含5个元素的整型数组
var nums [5]int

// 2. 声明并初始化一个固定长度数组
nums := [5]int{1, 2, 3, 4, 5}

// 3. 声明一个数组，长度由定义的元素来决定
nums := [...]int{1, 2, 3, 4, 5, 6, 7}
```
看上边的代码，前两个都很好理解，但是第三个`[...]`的形式很怪异，道理很好理解，就是`nums`的长度取决于后边定义的元素个数，但为什么要多三个点呢？能不能写成这样`nums := []int{1, 2, 3, 4, 5, 6, 7}`？

答：不能🙅！！省略三个点后，nums就声明为切片了，**切片可以理解为动态长度的数组，但内存结构和数组完全不同**！不要图方便就彼此混淆。

### 基本使用

```go
// 1. 索引访问
nums[0] = 12138
nums[1] = 9527

// 2. 遍历访问
for i, v := range nums {
	 fmt.Printf("nums[%d] = %d\n", i, v)
}
```

### 复制元素

```go
// 直接通过赋值表达式，可以复制数组内容
color1 := [...]string{"Red", "Green", "Blue"}

var color2 [3]string
color2 = color1
color1[0] = "Yellow"

fmt.Printf("color1: %v\n", color1) // color1: [Yellow Green Blue]
fmt.Printf("color2: %v\n", color2) // color2: [Red Green Blue]
```

### 指针数组

```go
// 和数组复制类似，nums2复制了nums1的内容
// 但由于其元素都是指针类型
// 所以修改nums2时，nums1也会受影响
nums1 := [...]*int{new(int), new(int), new(int)}
*nums1[0] = 10
*nums1[1] = 20
*nums1[2] = 30

var nums2 [3]*int
nums2 = nums1
*nums2[2] = 99 // 相当于修改nums1[2]
```

### 多维数组

```go
// 1. 声明一个多维(4行2列)数组
 var array [4][2]int

// 2. 声明并初始化一个多维数组
array := [4][2]int{{1, 2}, {3, 4}, {5, 6}, {7, 8}}

// 3. 声明一个多维数组，且仅初始化第一行所有列、第四行第二列
array := [4][2]int{1: {88, 99}, 3: {1: 66}}

// 4. 数组的复制和一维数组一样
var arr2 [4][2]int
arr2 = array
```

### 函数中数组传参 👈 务必要留意这条！

数组有非常多的应用场景：内容缓存、请求/应答消息等，此类数据有可能体积较为庞大，比如默认给某个buffer开2M的空间，让它在不同的函数间传递，然而GO语言`函数参数中，数组是以复制的形式传递的`，这就会导致每次调用函数`压栈`的开销特别大，如果您在来几个递归…那后果就是灾难性的。

所以，日常开发中，如果数组长度非常大，且作为一个”输入输出”参数，最好不要直接定义为数组，而是定义为数组指针。

## 切片

切片是对数组的进一步抽象，以便于达到“动态”增长数组的效果。但不要简单的理解为就是在数组的连续内存尾巴后“追加”新的内存，那是不阔愣滴～

### 切片的内存结构