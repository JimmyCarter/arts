# 嵌入式Linux驱动学习四：字符设备

由于Linux中`一切皆文件`的思想，字符设备(键盘/鼠标/串口)、块设备(存储器)、网络设备(套接字)作为三种主要设备类型，我们在用户层基本可以通过`open close read write`来完成对设备的绝大部分操作。其中字符设备是涵盖面最广的一种，而且其概念相对容易理解，因此以字符设备为切入口，掌握内核与用户层之间的调用机制是再合适不过了。

**本章主要学习**：

- 字符设备驱动的基本概念
- 如何向内核注册/注销一个字符设备
- 如何通过设备节点、文件API调用驱动的函数
- 驱动的内存管理
- udev自动创建设备节点

## 什么是字符设备？

所谓字符设备，泛指那些输入输出以串行方式、按顺序、一个字符一个字符的收发数据的设备。比如键盘，按键数据是一个一个发给系统的，哪怕是组合键；鼠标的坐标；LED灯；串口终端等。而这些数据如果不能及时被系统处理，要么被缓存，要么直接丢弃，但不论如何，当系统去处理这些数据的时候，也是按先来后到的顺序。

你可以设想以下，你的电脑突然卡顿了5秒钟，而这期间你疯狂打了10个字，毫无疑问这10个字的数据被缓存起来了，等系统空闲的时候开始处理它们，现在你是希望这10个字是按照你打的顺序出现在屏幕呢，还是希望它们毫无章法地出现在屏幕。

所以，字符设备，就是数据的IO总是以连续的形式处理的设备类型。

顺带提一句块设备，与字符设备概念做个对比。比如硬盘：你和你的右手出去约会并拍了很多照片回来，然后你把照片倒入电脑，而硬盘的存储空间并不是像水杯一样从下往上按顺序填满，而是根据某种算法“随机”存，所以在真实的硬盘中，存放你1号照片的存储区域旁边，并不是2号照片，可能是某份日语学习资料；同理，3号照片可能与去年下载的种子呆在一起。


## 第一个字符设备 meme

在操作系统中，设备不一定要真实存在，虚拟设备也是设备，可以通过文件函数进行操作。因此为了掌握字符设备的知识，最简单的方法就是自己动手写一个虚拟字符设备。好了，现在给这个虚拟设备取个名字——meme。

meme的中文意思是米姆、莫因，表示文化DNA的意思，总的来说它就是“记事本”，用户可以用多种方式读写它，而我给这个虚拟设备取这么个名字没别的意思——just for fun！

先来看看我打算要meme实现哪些内容：
1. 向内核注册/注销自己
2. 支持文件操作open/close/read/write
3. 支持内存映射mmap
4. 支持跳转和控制seek/ioctl

### 字符设备的注册与注销

一个字符设备的编号由**主设备号**和**次设备号**共同组成
- 主设备号(major)：表示设备的分类编号，比如1代表u盘、2代表显示器、3代表打印机
- 次设备号(minor)：表示同一分类的实例编号，比如1号u盘、2号u盘、3号u盘

Linux内核可以**静态**和**动态**申请主设备号，但主设备号是不允许重复使用的，也就是说如果123号设备类型已被某个驱动申请过了，如果你的驱动还拿这个号申请注册，肯定会失败。为了不给自己找麻烦，我仅通过动态申请来

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/cdev.h>

// 字符设备结构体，该字符设备的核心数据表示
static struct cdev cdev;

// 驱动的主设备编号，每种类型的设备都有唯一编号
static dev_t devno = 0;

// 模块加载函数
static int __init meme_init(void)
{
    // 1. 向内核申请分配一个主设备号，此设备号从0开始，分配1个，名称为meme
    if (alloc_chrdev_region(&devno, 0, 1, "meme") < 0 ) {
        printk(KERN_ERR"fail init\n");
        return (-1);
    }

    // 2. 初始化cdev结构体，并与fops文件操作之间建立联系
    cdev_init(&cdev, &fops);

    // 3. 正式向内核注册一个字符设备
    cdev_add(&cdev, devno, 1);

    printk(KERN_ALERT"meme init: %d:%d\n", MAJOR(devno), MINOR(devno));
    return 0;
}
module_init(meme_init);

// 模块卸载函数
static void __exit meme_exit(void)
{
    // 1. 向内核注销该字符设备
    cdev_del(&cdev);

    // 2. 向内核申请释放该设备号
    unregister_chrdev_region(devno, 1);

    printk("meme free\n");
}
module_exit(meme_exit);

// 杂七杂八的东西
MODULE_LICENSE("GPL v2");
MODULE_AUTHOR("Philon");
MODULE_DESCRIPTION("A character device driver");
```
